"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_sources_1 = require("webpack-sources");
const GraphHelpers_1 = __importDefault(require("webpack/lib/GraphHelpers"));
/**
 * Makes sure there are no dynamic chunks when the target is serverless
 * The dynamic chunks are integrated back into their parent chunk
 * This is to make sure there is a single render bundle instead of that bundle importing dynamic chunks
 */
const NEXT_REPLACE_BUILD_ID = '__NEXT_REPLACE__BUILD_ID__';
class ServerlessPlugin {
    constructor(buildId, { sourceMap = false } = {}) {
        this.buildId = buildId;
        this.sourceMap = sourceMap;
    }
    apply(compiler) {
        compiler.hooks.compilation.tap('ServerlessPlugin', compilation => {
            compilation.hooks.optimizeChunksBasic.tap('ServerlessPlugin', chunks => {
                chunks.forEach(chunk => {
                    // If chunk is not an entry point skip them
                    if (chunk.hasEntryModule()) {
                        const dynamicChunks = chunk.getAllAsyncChunks();
                        if (dynamicChunks.size !== 0) {
                            for (const dynamicChunk of dynamicChunks) {
                                for (const module of dynamicChunk.modulesIterable) {
                                    GraphHelpers_1.default.connectChunkAndModule(chunk, module);
                                }
                            }
                        }
                    }
                });
                compilation.hooks.afterOptimizeChunkAssets.tap('ServerlessPlugin', chunks => {
                    chunks
                        .reduce((acc, chunk) => acc.concat(chunk.files || []), [])
                        .forEach(file => {
                        const asset = compilation.assets[file];
                        let input;
                        let inputSourceMap;
                        if (this.sourceMap) {
                            if (asset.sourceAndMap) {
                                const sourceAndMap = asset.sourceAndMap();
                                inputSourceMap = sourceAndMap.map;
                                input = sourceAndMap.source;
                            }
                            else {
                                inputSourceMap = asset.map();
                                input = asset.source();
                            }
                        }
                        else {
                            input = asset.source();
                        }
                        const output = input.replace(NEXT_REPLACE_BUILD_ID, this.buildId);
                        if (this.sourceMap && inputSourceMap) {
                            compilation.assets[file] = new webpack_sources_1.SourceMapSource(output, file, inputSourceMap);
                        }
                        else {
                            compilation.assets[file] = new webpack_sources_1.RawSource(output);
                        }
                    });
                });
            });
        });
    }
}
exports.ServerlessPlugin = ServerlessPlugin;
